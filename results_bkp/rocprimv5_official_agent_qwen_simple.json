{
  "metadata": {},
  "results": [
    {
      "instance_id": "rocprim_rocprim_include_rocprim_block_block_exchange_hpp",
      "success": true,
      "reward": 0.0,
      "speedup": -1.0,
      "exit_status": "Submitted",
      "error": null,
      "git_diff": null,
      "model_calls": 3,
      "eval_success": false,
      "eval_reason": null,
      "eval_error": "No changes detected relative to HEAD",
      "eval_exit_code": null,
      "eval_timed_out": null
    },
    {
      "instance_id": "rocprim_rocprim_include_rocprim_block_block_radix_rank_hpp",
      "success": true,
      "reward": 0.0,
      "speedup": -1.0,
      "exit_status": "Submitted",
      "error": null,
      "git_diff": "diff --git a/projects/rocprim/rocprim/include/rocprim/block/block_radix_rank.hpp b/projects/rocprim/rocprim/include/rocprim/block/block_radix_rank.hpp\nindex 610b8b77a7..c96efe5df8 100644\n--- a/projects/rocprim/rocprim/include/rocprim/block/block_radix_rank.hpp\n+++ b/projects/rocprim/rocprim/include/rocprim/block/block_radix_rank.hpp\n@@ -28,7 +28,6 @@\n #include \"config.hpp\"\n \n #include \"detail/block_radix_rank_basic.hpp\"\n-#include \"detail/block_radix_rank_match.hpp\"\n \n /// \\addtogroup blockmodule\n /// @{\n",
      "model_calls": 14,
      "eval_success": false,
      "eval_reason": null,
      "eval_error": "Test build failed",
      "eval_exit_code": null,
      "eval_timed_out": null
    },
    {
      "instance_id": "rocprim_rocprim_include_rocprim_block_block_radix_sort_hpp",
      "success": true,
      "reward": 0.0,
      "speedup": -1.0,
      "exit_status": "Submitted",
      "error": null,
      "git_diff": null,
      "model_calls": 16,
      "eval_success": false,
      "eval_reason": null,
      "eval_error": "No changes detected relative to HEAD",
      "eval_exit_code": null,
      "eval_timed_out": null
    },
    {
      "instance_id": "rocprim_rocprim_include_rocprim_block_block_histogram_hpp",
      "success": true,
      "reward": 0.3,
      "speedup": 0.9952063634913164,
      "exit_status": "Submitted",
      "error": null,
      "git_diff": null,
      "model_calls": 32,
      "eval_success": true,
      "eval_reason": null,
      "eval_error": null,
      "eval_exit_code": -1,
      "eval_timed_out": false
    },
    {
      "instance_id": "rocprim_rocprim_include_rocprim_block_block_run_length_decode_hpp",
      "success": true,
      "reward": 0.0,
      "speedup": -1.0,
      "exit_status": "Submitted",
      "error": null,
      "git_diff": "diff --git a/projects/rocprim/rocprim/include/rocprim/block/block_run_length_decode.hpp b/projects/rocprim/rocprim/include/rocprim/block/block_run_length_decode.hpp\nindex 6cbe1c626e..8d40734ca5 100644\n--- a/projects/rocprim/rocprim/include/rocprim/block/block_run_length_decode.hpp\n+++ b/projects/rocprim/rocprim/include/rocprim/block/block_run_length_decode.hpp\n@@ -1,35 +1,3 @@\n-/******************************************************************************\n- * Copyright (c) 2010-2011, Duane Merrill.  All rights reserved.\n- * Copyright (c) 2011-2018, NVIDIA CORPORATION.  All rights reserved.\n- * Modifications Copyright (c) 2021-2024, Advanced Micro Devices, Inc.  All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions are met:\n- *     * Redistributions of source code must retain the above copyright\n- *       notice, this list of conditions and the following disclaimer.\n- *     * Redistributions in binary form must reproduce the above copyright\n- *       notice, this list of conditions and the following disclaimer in the\n- *       documentation and/or other materials provided with the distribution.\n- *     * Neither the name of the NVIDIA CORPORATION nor the\n- *       names of its contributors may be used to endorse or promote products\n- *       derived from this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n- * DISCLAIMED. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY\n- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\n- ******************************************************************************/\n-\n-#ifndef ROCPRIM_BLOCK_BLOCK_RUN_LENGTH_DECODE_HPP_\n-#define ROCPRIM_BLOCK_BLOCK_RUN_LENGTH_DECODE_HPP_\n-\n #include \"../block/block_scan.hpp\"\n #include \"../config.hpp\"\n #include \"../detail/temp_storage.hpp\"\n@@ -48,333 +16,26 @@ BEGIN_ROCPRIM_NAMESPACE\n  * A run of length zero may not be followed by a run length that is not zero.\n  *\n  * \\par Examples\n- * \\parblock\n- * Due to the nature of the run-length decoding algorithm (\"decompression\"), the output size of the run-length decoded\n- * array is runtime-dependent and potentially without any upper bound. To address this, `block_run_length_decode` allows\n- * retrieving a \"window\" from the run-length decoded array. The window's offset can be specified and `BLOCK_THREADS *\n- * DECODED_ITEMS_PER_THREAD` (i.e., referred to as `window_size`) decoded items from the specified window will be returned.\n- *\n- * \\par\n- * \\code\n- * __global__ void ExampleKernel(...)\n- * {\n- *   // Specialising block_run_length_decode to run-length decode items of type uint64_t\n- *   using RunItemT = uint64_t;\n- *   // Type large enough to index into the run-length decoded array\n- *   using RunLengthT = uint32_t;\n- *\n- *   // Specialising block_run_length_decode for a 1D block of 128 threads\n- *   constexpr int BLOCK_DIM_X = 128;\n- *   // Specialising block_run_length_decode to have each thread contribute 2 run-length encoded runs\n- *   constexpr int RUNS_PER_THREAD = 2;\n- *   // Specialising block_run_length_decode to have each thread hold 4 run-length decoded items\n- *   constexpr int DECODED_ITEMS_PER_THREAD = 4;\n- *\n- *   // Specialize BlockRadixSort for a 1D block of 128 threads owning 4 integer items each\n- *   using block_run_length_decodeT =\n- *     hipcub::block_run_length_decode<RunItemT, BLOCK_DIM_X, RUNS_PER_THREAD, DECODED_ITEMS_PER_THREAD>;\n- *\n- *   // Allocate shared memory for block_run_length_decode\n- *   __shared__ typename block_run_length_decodeT::TempStorage temp_storage;\n- *\n- *   // The run-length encoded items and how often they shall be repeated in the run-length decoded output\n- *   RunItemT run_values[RUNS_PER_THREAD];\n- *   RunLengthT run_lengths[RUNS_PER_THREAD];\n- *   ...\n- *\n- *   // Initialize the block_run_length_decode with the runs that we want to run-length decode\n- *   uint32_t total_decoded_size = 0;\n- *   block_run_length_decodeT block_rld(temp_storage, run_values, run_lengths, total_decoded_size);\n- *\n- *   // Run-length decode (\"decompress\") the runs into a window buffer of limited size. This is repeated until all runs\n- *   // have been decoded.\n- *   uint32_t decoded_window_offset = 0U;\n- *   while (decoded_window_offset < total_decoded_size)\n- *   {\n- *     RunLengthT relative_offsets[DECODED_ITEMS_PER_THREAD];\n- *     RunItemT decoded_items[DECODED_ITEMS_PER_THREAD];\n- *\n- *     // The number of decoded items that are valid within this window (aka pass) of run-length decoding\n- *     uint32_t num_valid_items = total_decoded_size - decoded_window_offset;\n- *     block_rld.run_length_decode(decoded_items, relative_offsets, decoded_window_offset);\n- *\n- *     decoded_window_offset += BLOCK_DIM_X * DECODED_ITEMS_PER_THREAD;\n- *\n- *     ...\n- *   }\n- * }\n- * \\endcode\n- * \\par\n- * Suppose the set of input \\p run_values across the block of threads is\n- * <tt>{ [0, 1], [2, 3], [4, 5], [6, 7], ..., [254, 255] }</tt> and\n- * \\p run_lengths is <tt>{ [1, 2], [3, 4], [5, 1], [2, 3], ..., [5, 1] }</tt>.\n- * \\par\n- * The corresponding output \\p decoded_items in those threads will be <tt>{ [0, 1, 1, 2], [2, 2, 3, 3], [3, 3, 4, 4],\n- * [4, 4, 4, 5], ..., [169, 169, 170, 171] }</tt> and \\p relative_offsets will be <tt>{ [0, 0, 1, 0], [1, 2, 0, 1], [2,\n- * 3, 0, 1], [2, 3, 4, 0], ..., [3, 4, 0, 0] }</tt> during the first iteration of the while loop.\n- * \\endparblock\n- *\n- * \\tparam ItemT The data type of the items being run-length decoded\n- * \\tparam BLOCK_DIM_X The thread block length in threads along the X dimension\n- * \\tparam RUNS_PER_THREAD The number of consecutive runs that each thread contributes\n- * \\tparam DECODED_ITEMS_PER_THREAD The maximum number of decoded items that each thread holds\n- * \\tparam DecodedOffsetT Type used to index into the block's decoded items (large enough to hold the sum over all the\n- * runs' lengths)\n- * \\tparam BLOCK_DIM_Y The thread block length in threads along the Y dimension\n- * \\tparam BLOCK_DIM_Z The thread block length in threads along the Z dimension\n  */\n-template<typename ItemT,\n-         unsigned int BlockSizeX,\n-         int          RUNS_PER_THREAD,\n-         int          DECODED_ITEMS_PER_THREAD,\n-         typename DecodedOffsetT = uint32_t,\n-         unsigned int BlockSizeY = 1,\n-         unsigned int BlockSizeZ = 1>\n+\n+template <typename ItemT, typename DecodedOffsetT>\n class block_run_length_decode\n {\n-private:\n-    /// The thread block size in threads\n-    static constexpr int BLOCK_THREADS = BlockSizeX * BlockSizeY * BlockSizeZ;\n-\n-    /// The number of runs that the block decodes (out-of-bounds items may be padded with run lengths of '0')\n-    static constexpr int BLOCK_RUNS = BLOCK_THREADS * RUNS_PER_THREAD;\n-\n-    /// block_scan used to determine the beginning of each run (i.e., prefix sum over the runs' length)\n-    using block_scan_type = rocprim::block_scan<DecodedOffsetT,\n-                                                BlockSizeX,\n-                                                rocprim::block_scan_algorithm::using_warp_scan,\n-                                                BlockSizeY,\n-                                                BlockSizeZ>;\n-\n-    /// Type used to index into the block's runs\n-    using RunOffsetT = uint32_t;\n-\n-    /// Shared memory type required by this thread block\n-    union storage_type_\n-    {\n-        typename block_scan_type::storage_type offset_scan;\n-        struct\n-        {\n-            ItemT          run_values[BLOCK_RUNS];\n-            DecodedOffsetT run_offsets[BLOCK_RUNS];\n-        } runs;\n-    };\n-\n-    ROCPRIM_DEVICE ROCPRIM_INLINE storage_type_& private_storage()\n-    {\n-        ROCPRIM_SHARED_MEMORY storage_type private_storage;\n-        return private_storage.get();\n-    }\n-\n-    storage_type_& temp_storage;\n-\n-    uint32_t linear_tid;\n-\n public:\n-    /// \\brief Struct used to allocate a temporary memory that is required for thread\n-    /// communication during operations provided by related parallel primitive.\n-    ///\n-    /// Depending on the implemention the operations exposed by parallel primitive may\n-    /// require a temporary storage for thread communication. The storage should be allocated\n-    /// using keywords <tt>__shared__</tt>. It can be aliased to\n-    /// an externally allocated memory, or be a part of a union type with other storage types\n-    /// to increase shared memory reusability.\n-    ROCPRIM_DETAIL_SUPPRESS_DEPRECATION_WITH_PUSH\n-    using storage_type = detail::raw_storage<storage_type_>;\n-    ROCPRIM_DETAIL_SUPPRESS_DEPRECATION_POP\n+    // ... (existing code)\n \n-    /**\n-   * \\brief Constructor specialised for user-provided temporary storage, initializing using the runs' lengths. The\n-   * algorithm's temporary storage may not be repurposed between the constructor call and subsequent\n-   * <b>run_length_decode</b> calls.\n-   */\n-    template<typename RunLengthT, typename TotalDecodedSizeT>\n-    ROCPRIM_DEVICE ROCPRIM_INLINE\n-        block_run_length_decode(storage_type& temp_storage,\n-                                ItemT (&run_values)[RUNS_PER_THREAD],\n-                                RunLengthT (&run_lengths)[RUNS_PER_THREAD],\n-                                TotalDecodedSizeT& total_decoded_size)\n-        : temp_storage(temp_storage.get())\n-        , linear_tid(::rocprim::flat_block_thread_id<BlockSizeX, BlockSizeY, BlockSizeZ>())\n+    __device__ __forceinline__ void\n+    run_length_decode(ItemT (&decoded_items)[DECODED_ITEMS_PER_THREAD],\n+                      DecodedOffsetT from_decoded_offset = 0)\n     {\n-        init_with_run_lengths(run_values, run_lengths, total_decoded_size);\n-    }\n+        __shared__ typename detail::shared_memory<sizeof(typename std::aligned_storage<sizeof(decltype(temp_storage.runs.run_values[0]))>::type)>::type sm;\n+        sm.template set<0>(temp_storage.runs.run_values[0]);\n+        sm.template set<1>(temp_storage.runs.run_offsets[0]);\n+        sm.template set<2>(temp_storage.runs.run_offsets[1]);\n \n-    /**\n-     * \\brief Constructor specialised for user-provided temporary storage, initializing using the runs' offsets. The\n-     * algorithm's temporary storage may not be repurposed between the constructor call and subsequent\n-     * <b>run_length_decode</b> calls.\n-     */\n-    template<typename UserRunOffsetT>\n-    ROCPRIM_DEVICE ROCPRIM_INLINE\n-        block_run_length_decode(storage_type& temp_storage,\n-                                ItemT (&run_values)[RUNS_PER_THREAD],\n-                                UserRunOffsetT (&run_offsets)[RUNS_PER_THREAD])\n-        : temp_storage(temp_storage.get())\n-        , linear_tid(::rocprim::flat_block_thread_id<BlockSizeX, BlockSizeY, BlockSizeZ>())\n-    {\n-        init_with_run_offsets(run_values, run_offsets);\n-    }\n-\n-    /**\n-     * \\brief Constructor specialised for static temporary storage, initializing using the runs' lengths.\n-     */\n-    template<typename RunLengthT, typename TotalDecodedSizeT>\n-    ROCPRIM_DEVICE ROCPRIM_INLINE\n-        block_run_length_decode(ItemT (&run_values)[RUNS_PER_THREAD],\n-                                RunLengthT (&run_lengths)[RUNS_PER_THREAD],\n-                                TotalDecodedSizeT& total_decoded_size)\n-        : temp_storage(private_storage())\n-        , linear_tid(::rocprim::flat_block_thread_id<BlockSizeX, BlockSizeY, BlockSizeZ>())\n-    {\n-        init_with_run_lengths(run_values, run_lengths, total_decoded_size);\n-    }\n-\n-    /**\n-     * \\brief Constructor specialised for static temporary storage, initializing using the runs' offsets.\n-     */\n-    template<typename UserRunOffsetT>\n-    ROCPRIM_DEVICE ROCPRIM_INLINE\n-        block_run_length_decode(ItemT (&run_values)[RUNS_PER_THREAD],\n-                                UserRunOffsetT (&run_offsets)[RUNS_PER_THREAD])\n-        : temp_storage(private_storage())\n-        , linear_tid(::rocprim::flat_block_thread_id<BlockSizeX, BlockSizeY, BlockSizeZ>())\n-    {\n-        init_with_run_offsets(run_values, run_offsets);\n-    }\n-\n-private:\n-    template<typename RunOffsetT>\n-    ROCPRIM_DEVICE ROCPRIM_INLINE void\n-        init_with_run_offsets(ItemT (&run_values)[RUNS_PER_THREAD],\n-                              RunOffsetT (&run_offsets)[RUNS_PER_THREAD])\n-    {\n-        // Keep the runs' items and the offsets of each run's beginning in the temporary storage\n-        RunOffsetT thread_dst_offset\n-            = static_cast<RunOffsetT>(linear_tid) * static_cast<RunOffsetT>(RUNS_PER_THREAD);\n-\n-#pragma unroll\n-        for(int i = 0; i < RUNS_PER_THREAD; ++i, ++thread_dst_offset)\n-        {\n-            temp_storage.runs.run_values[thread_dst_offset]  = run_values[i];\n-            temp_storage.runs.run_offsets[thread_dst_offset] = run_offsets[i];\n-        }\n-\n-        // Ensure run offsets and run values have been writen to shared memory\n-        syncthreads();\n-    }\n-\n-    template<typename RunLengthT, typename TotalDecodedSizeT>\n-    ROCPRIM_DEVICE ROCPRIM_INLINE void\n-        init_with_run_lengths(ItemT (&run_values)[RUNS_PER_THREAD],\n-                              RunLengthT (&run_lengths)[RUNS_PER_THREAD],\n-                              TotalDecodedSizeT& total_decoded_size)\n-    {\n-        // Compute the offset for the beginning of each run\n-        DecodedOffsetT run_offsets[RUNS_PER_THREAD];\n-#pragma unroll\n-        for(int i = 0; i < RUNS_PER_THREAD; ++i)\n-        {\n-            run_offsets[i] = static_cast<DecodedOffsetT>(run_lengths[i]);\n-        }\n-\n-        DecodedOffsetT decoded_size_aggregate{};\n-        block_scan_type().exclusive_scan(run_offsets,\n-                                         run_offsets,\n-                                         0,\n-                                         decoded_size_aggregate,\n-                                         temp_storage.offset_scan,\n-                                         rocprim::plus<DecodedOffsetT>{});\n-        total_decoded_size = static_cast<TotalDecodedSizeT>(decoded_size_aggregate);\n-\n-        // Ensure the prefix scan's temporary storage can be reused (may be superfluous, but depends on scan implementation)\n-        syncthreads();\n-\n-        init_with_run_offsets(run_values, run_offsets);\n-    }\n-\n-public:\n-    /**\n-     * \\brief Run-length decodes the runs previously passed via a call to Init(...) and returns the run-length decoded\n-     * items in a blocked arrangement to \\p decoded_items. If the number of run-length decoded items exceeds the\n-     * run-length decode buffer (i.e., <b>DECODED_ITEMS_PER_THREAD * BLOCK_THREADS</b>), only the items that fit within\n-     * the buffer are returned. Subsequent calls to <b>run_length_decode</b> adjusting \\p from_decoded_offset can be\n-     * used to retrieve the remaining run-length decoded items. Calling __syncthreads() between any two calls to\n-     * <b>run_length_decode</b> is not required.\n-     * \\p item_offsets can be used to retrieve each run-length decoded item's relative index within its run. E.g., the\n-     * run-length encoded array of `3, 1, 4` with the respective run lengths of `2, 1, 3` would yield the run-length\n-     * decoded array of `3, 3, 1, 4, 4, 4` with the relative offsets of `0, 1, 0, 0, 1, 2`.\n-     *\n-     * \\param[out] decoded_items The run-length decoded items to be returned in a blocked arrangement\n-     * \\param[out] item_offsets The run-length decoded items' relative offset within the run they belong to\n-     * \\param[in] from_decoded_offset If invoked with from_decoded_offset that is larger than total_decoded_size results\n-     * in undefined behavior.\n-     */\n-    template<typename RelativeOffsetT>\n-    ROCPRIM_DEVICE ROCPRIM_INLINE void\n-        run_length_decode(ItemT (&decoded_items)[DECODED_ITEMS_PER_THREAD],\n-                          RelativeOffsetT (&item_offsets)[DECODED_ITEMS_PER_THREAD],\n-                          DecodedOffsetT from_decoded_offset = 0)\n-    {\n-        // The (global) offset of the first item decoded by this thread\n-        DecodedOffsetT thread_decoded_offset\n-            = from_decoded_offset + linear_tid * DECODED_ITEMS_PER_THREAD;\n-\n-        // The run that the first decoded item of this thread belongs to\n-        // If this thread's <thread_decoded_offset> is already beyond the total decoded size, it will be assigned to the\n-        // last run\n-        RunOffsetT current_run\n-            = rocprim::static_upper_bound<BLOCK_RUNS>(temp_storage.runs.run_offsets,\n-                                                      BLOCK_RUNS,\n-                                                      thread_decoded_offset)\n-              - static_cast<RunOffsetT>(1U);\n-\n-        // Set the current_run_end to thread_decoded_offset to trigger new run branch in the first iteration\n-        DecodedOffsetT current_run_begin, current_run_end = thread_decoded_offset;\n-\n-        ItemT val{};\n-\n-#pragma unroll\n-        for(DecodedOffsetT i = 0; i < DECODED_ITEMS_PER_THREAD; ++i, ++thread_decoded_offset)\n-        {\n-            // If we are in a new run...\n-            if(thread_decoded_offset == current_run_end)\n-            {\n-                // The value of the new run\n-                val = temp_storage.runs.run_values[current_run];\n-\n-                // The run bounds\n-                current_run_begin = temp_storage.runs.run_offsets[current_run];\n-                current_run_end   = temp_storage.runs.run_offsets[++current_run];\n-            }\n-\n-            // Decode the current run by storing the run's value\n-            decoded_items[i] = val;\n-            item_offsets[i]  = thread_decoded_offset - current_run_begin;\n-        }\n-    }\n-\n-    /**\n-     * \\brief Run-length decodes the runs previously passed via a call to Init(...) and returns the run-length decoded\n-     * items in a blocked arrangement to \\p decoded_items. If the number of run-length decoded items exceeds the\n-     * run-length decode buffer (i.e., <b>DECODED_ITEMS_PER_THREAD * BLOCK_THREADS</b>), only the items that fit within\n-     * the buffer are returned. Subsequent calls to <b>run_length_decode</b> adjusting \\p from_decoded_offset can be\n-     * used to retrieve the remaining run-length decoded items. Calling __syncthreads() between any two calls to\n-     * <b>run_length_decode</b> is not required.\n-     *\n-     * \\param[out] decoded_items The run-length decoded items to be returned in a blocked arrangement\n-     * \\param[in] from_decoded_offset If invoked with from_decoded_offset that is larger than total_decoded_size results\n-     * in undefined behavior.\n-     */\n-    ROCPRIM_DEVICE ROCPRIM_INLINE void\n-        run_length_decode(ItemT (&decoded_items)[DECODED_ITEMS_PER_THREAD],\n-                          DecodedOffsetT from_decoded_offset = 0)\n-    {\n         DecodedOffsetT item_offsets[DECODED_ITEMS_PER_THREAD];\n         run_length_decode(decoded_items, item_offsets, from_decoded_offset);\n     }\n };\n \n END_ROCPRIM_NAMESPACE\n-\n-#endif\n",
      "model_calls": 10,
      "eval_success": false,
      "eval_reason": null,
      "eval_error": "Test build failed",
      "eval_exit_code": null,
      "eval_timed_out": null
    },
    {
      "instance_id": "rocprim_rocprim_include_rocprim_block_block_reduce_hpp",
      "success": true,
      "reward": 0.0,
      "speedup": -1.0,
      "exit_status": "Submitted",
      "error": null,
      "git_diff": "diff --git a/projects/rocprim/rocprim/include/rocprim/block/block_reduce.hpp b/projects/rocprim/rocprim/include/rocprim/block/block_reduce.hpp\nindex f3451ee1ff..6f26e580f4 100644\n--- a/projects/rocprim/rocprim/include/rocprim/block/block_reduce.hpp\n+++ b/projects/rocprim/rocprim/include/rocprim/block/block_reduce.hpp\n@@ -30,7 +30,7 @@\n #include \"../functional.hpp\"\n \n #include \"detail/block_reduce_warp_reduce.hpp\"\n-#include \"detail/block_reduce_raking_reduce.hpp\"\n+#include \"detail/block_reduce_raking_reduce_optimized.hpp\"\n \n \n /// \\addtogroup blockmodule\n@@ -78,7 +78,7 @@ struct select_block_reduce_impl<block_reduce_algorithm::raking_reduce>\n              unsigned int            BlockSizeY,\n              unsigned int            BlockSizeZ,\n              arch::wavefront::target TargetWaveSize>\n-    using type = block_reduce_raking_reduce<T, BlockSizeX, BlockSizeY, BlockSizeZ, TargetWaveSize>;\n+    using type = block_reduce_raking_reduce_optimized<T, BlockSizeX, BlockSizeY, BlockSizeZ, TargetWaveSize>;\n };\n \n template<>\n@@ -90,7 +90,7 @@ struct select_block_reduce_impl<block_reduce_algorithm::raking_reduce_commutativ\n              unsigned int            BlockSizeZ,\n              arch::wavefront::target TargetWaveSize>\n     using type\n-        = block_reduce_raking_reduce<T, BlockSizeX, BlockSizeY, BlockSizeZ, TargetWaveSize, true>;\n+        = block_reduce_raking_reduce_optimized<T, BlockSizeX, BlockSizeY, BlockSizeZ, TargetWaveSize, true>;\n };\n \n \n",
      "model_calls": 7,
      "eval_success": false,
      "eval_reason": null,
      "eval_error": "Test build failed",
      "eval_exit_code": null,
      "eval_timed_out": null
    },
    {
      "instance_id": "rocprim_rocprim_include_rocprim_block_block_scan_hpp",
      "success": true,
      "reward": 0.0,
      "speedup": -1.0,
      "exit_status": "Submitted",
      "error": null,
      "git_diff": "diff --git a/projects/rocprim/rocprim/CMakeLists.txt b/projects/rocprim/rocprim/CMakeLists.txt\nindex 0eda121b57..f46a4463f0 100644\n--- a/projects/rocprim/rocprim/CMakeLists.txt\n+++ b/projects/rocprim/rocprim/CMakeLists.txt\n@@ -1,72 +1,6 @@\n-# MIT License\n-#\n-# Copyright (c) 2017-2024 Advanced Micro Devices, Inc. All rights reserved.\n-#\n-# Permission is hereby granted, free of charge, to any person obtaining a copy\n-# of this software and associated documentation files (the \"Software\"), to deal\n-# in the Software without restriction, including without limitation the rights\n-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n-# copies of the Software, and to permit persons to whom the Software is\n-# furnished to do so, subject to the following conditions:\n-#\n-# The above copyright notice and this permission notice shall be included in all\n-# copies or substantial portions of the Software.\n-#\n-# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n-# SOFTWARE.\n-\n-# rocPRIM header-only library\n-\n-# Configure a header file to pass the rocPRIM version\n-configure_file(\n-  \"${CMAKE_CURRENT_SOURCE_DIR}/include/rocprim/rocprim_version.hpp.in\"\n-  \"${CMAKE_CURRENT_BINARY_DIR}/include/rocprim/rocprim_version.hpp\"\n-  @ONLY\n-)\n-\n-# Only header target, does not include dependencies\n-add_library(rocprim INTERFACE)\n-target_include_directories(rocprim\n-  INTERFACE\n-    $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/include>\n-    $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/include/rocprim>\n-    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>\n-    $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>\n-)\n-\n-# This target links against HIP library\n-add_library(rocprim_hip INTERFACE)\n-target_link_libraries(rocprim_hip INTERFACE rocprim hip::device)\n-\n-\n-# Installation\n-if (ROCPRIM_INSTALL)\n-  # We need to install headers manually as rocm_install_targets\n-  # does not support header-only libraries (INTERFACE targets)\n-  rocm_install_targets(\n-    TARGETS rocprim rocprim_hip\n-  )\n-\n-  rocm_install(\n-    DIRECTORY\n-      \"${CMAKE_CURRENT_SOURCE_DIR}/include/\"\n-      \"${PROJECT_BINARY_DIR}/rocprim/include/\"\n-      DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\n-    FILES_MATCHING\n-    PATTERN \"*.h\"\n-    PATTERN \"*.hpp\"\n-    PERMISSIONS OWNER_WRITE OWNER_READ GROUP_READ WORLD_READ\n-  )\n-\n-  # Export targets\n-  rocm_export_targets(\n-    TARGETS roc::rocprim roc::rocprim_hip\n-    DEPENDS PACKAGE hip\n-    NAMESPACE roc::\n-  )\n-endif()\n+cmake_minimum_required(VERSION 3.22)\n+project(rocprim)\n+add_subdirectory(include)\n+add_subdirectory(src)\n+add_subdirectory(test)\n+add_subdirectory(benchmark)\n",
      "model_calls": 26,
      "eval_success": false,
      "eval_reason": null,
      "eval_error": "Test build failed",
      "eval_exit_code": null,
      "eval_timed_out": null
    },
    {
      "instance_id": "rocprim_rocprim_include_rocprim_block_block_sort_hpp",
      "success": true,
      "reward": 0.0,
      "speedup": -1.0,
      "exit_status": "Submitted",
      "error": null,
      "git_diff": null,
      "model_calls": 24,
      "eval_success": false,
      "eval_reason": null,
      "eval_error": "No changes detected relative to HEAD",
      "eval_exit_code": null,
      "eval_timed_out": null
    },
    {
      "instance_id": "rocprim_rocprim_include_rocprim_device_device_adjacent_find_hpp",
      "success": true,
      "reward": 0.0,
      "speedup": -1.0,
      "exit_status": "Submitted",
      "error": null,
      "git_diff": null,
      "model_calls": 10,
      "eval_success": false,
      "eval_reason": null,
      "eval_error": "No changes detected relative to HEAD",
      "eval_exit_code": null,
      "eval_timed_out": null
    },
    {
      "instance_id": "rocprim_rocprim_include_rocprim_device_device_batch_memcpy_hpp",
      "success": true,
      "reward": 0.0,
      "speedup": -1.0,
      "exit_status": "Submitted",
      "error": null,
      "git_diff": null,
      "model_calls": 18,
      "eval_success": false,
      "eval_reason": null,
      "eval_error": "No changes detected relative to HEAD",
      "eval_exit_code": null,
      "eval_timed_out": null
    },
    {
      "instance_id": "rocprim_rocprim_include_rocprim_device_device_binary_search_hpp",
      "success": true,
      "reward": 0.0,
      "speedup": -1.0,
      "exit_status": "Submitted",
      "error": null,
      "git_diff": null,
      "model_calls": 11,
      "eval_success": false,
      "eval_reason": null,
      "eval_error": "No changes detected relative to HEAD",
      "eval_exit_code": null,
      "eval_timed_out": null
    },
    {
      "instance_id": "rocprim_rocprim_include_rocprim_device_device_adjacent_difference_hpp",
      "success": true,
      "reward": -0.2,
      "speedup": 0.0,
      "exit_status": "Submitted",
      "error": null,
      "git_diff": null,
      "model_calls": 25,
      "eval_success": true,
      "eval_reason": null,
      "eval_error": null,
      "eval_exit_code": -1,
      "eval_timed_out": false
    },
    {
      "instance_id": "rocprim_rocprim_include_rocprim_device_device_find_end_hpp",
      "success": true,
      "reward": 0.0,
      "speedup": -1.0,
      "exit_status": "Submitted",
      "error": null,
      "git_diff": null,
      "model_calls": 3,
      "eval_success": false,
      "eval_reason": null,
      "eval_error": "No changes detected relative to HEAD",
      "eval_exit_code": null,
      "eval_timed_out": null
    },
    {
      "instance_id": "rocprim_rocprim_include_rocprim_device_device_histogram_hpp",
      "success": true,
      "reward": 0.0,
      "speedup": -1.0,
      "exit_status": "Submitted",
      "error": null,
      "git_diff": "diff --git a/projects/rocprim/rocprim/include/rocprim/device/device_histogram.hpp b/projects/rocprim/rocprim/include/rocprim/device/device_histogram.hpp\nindex 1811692cce..ed0385b50b 100644\n--- a/projects/rocprim/rocprim/include/rocprim/device/device_histogram.hpp\n+++ b/projects/rocprim/rocprim/include/rocprim/device/device_histogram.hpp\n@@ -1397,6 +1397,7 @@ inline hipError_t histogram_range(void*          temporary_storage,\n /// void * temporary_storage_ptr = nullptr;\n /// // Get required size of the temporary storage\n /// rocprim::multi_histogram_range<4, 3>(\n+    __shared__ int shared_histogram[LOCAL_HISTOGRAM_SIZE];\n ///     temporary_storage_ptr, temporary_storage_size_bytes,\n ///     samples, size,\n ///     histogram, levels, level_values\n@@ -1407,6 +1408,7 @@ inline hipError_t histogram_range(void*          temporary_storage,\n ///\n /// // compute histograms\n /// rocprim::multi_histogram_range<4, 3>(\n+    __shared__ int shared_histogram[LOCAL_HISTOGRAM_SIZE];\n ///     temporary_storage_ptr, temporary_storage_size_bytes,\n ///     samples, size,\n ///     histogram, levels, level_values\n@@ -1515,6 +1517,7 @@ inline hipError_t multi_histogram_range(void*          temporary_storage,\n /// void * temporary_storage_ptr = nullptr;\n /// // Get required size of the temporary storage\n /// rocprim::multi_histogram_range<4, 3>(\n+    __shared__ int shared_histogram[LOCAL_HISTOGRAM_SIZE];\n ///     temporary_storage_ptr, temporary_storage_size_bytes,\n ///     samples, columns, rows, row_stride_bytes,\n ///     histogram, levels, level_values\n@@ -1525,6 +1528,7 @@ inline hipError_t multi_histogram_range(void*          temporary_storage,\n ///\n /// // compute histograms\n /// rocprim::multi_histogram_range<4, 3>(\n+    __shared__ int shared_histogram[LOCAL_HISTOGRAM_SIZE];\n ///     temporary_storage_ptr, temporary_storage_size_bytes,\n ///     samples, columns, rows, row_stride_bytes,\n ///     histogram, levels, level_values\n",
      "model_calls": 16,
      "eval_success": false,
      "eval_reason": null,
      "eval_error": "Test build failed",
      "eval_exit_code": null,
      "eval_timed_out": null
    },
    {
      "instance_id": "rocprim_rocprim_include_rocprim_device_device_memory_hpp",
      "success": true,
      "reward": 0.0,
      "speedup": -1.0,
      "exit_status": "Submitted",
      "error": null,
      "git_diff": "diff --git a/projects/rocprim/rocprim/include/rocprim/device/device_memcpy_config.hpp b/projects/rocprim/rocprim/include/rocprim/device/device_memcpy_config.hpp\nindex 5e8af2a3a6..f1bae79146 100644\n--- a/projects/rocprim/rocprim/include/rocprim/device/device_memcpy_config.hpp\n+++ b/projects/rocprim/rocprim/include/rocprim/device/device_memcpy_config.hpp\n@@ -56,7 +56,8 @@ struct wrapped_batch_memcpy_config\n \n // Specialization for selecting the default configuration for out of place\n template<typename Value, bool IsMemCpy>\n-struct wrapped_batch_memcpy_config<default_config, Value, IsMemCpy>\n+struct wrapped_batch_memcpy_config<default_config, \\\n+            .set_block_dim(256) Value, IsMemCpy>\n {\n     template<target_arch Arch>\n     struct architecture_config\n@@ -78,7 +79,8 @@ constexpr batch_memcpy_config_params\n template<class Value, bool IsMemCpy>\n template<target_arch Arch>\n constexpr batch_memcpy_config_params\n-    wrapped_batch_memcpy_config<rocprim::default_config, Value, IsMemCpy>::architecture_config<\n+    wrapped_batch_memcpy_config<rocprim::default_config, \\\n+            .set_block_dim(256) Value, IsMemCpy>::architecture_config<\n         Arch>::params;\n #endif // DOXYGEN_SHOULD_SKIP_THIS\n \n",
      "model_calls": 8,
      "eval_success": false,
      "eval_reason": null,
      "eval_error": "Test build failed",
      "eval_exit_code": null,
      "eval_timed_out": null
    },
    {
      "instance_id": "rocprim_rocprim_include_rocprim_block_block_discontinuity_hpp",
      "success": true,
      "reward": 0.0,
      "speedup": -1.0,
      "exit_status": "Submitted",
      "error": null,
      "git_diff": null,
      "model_calls": 35,
      "eval_success": false,
      "eval_reason": null,
      "eval_error": "No changes detected relative to HEAD",
      "eval_exit_code": null,
      "eval_timed_out": null
    },
    {
      "instance_id": "rocprim_rocprim_include_rocprim_device_device_merge_hpp",
      "success": true,
      "reward": 0.0,
      "speedup": -1.0,
      "exit_status": "Submitted",
      "error": null,
      "git_diff": null,
      "model_calls": 9,
      "eval_success": false,
      "eval_reason": null,
      "eval_error": "No changes detected relative to HEAD",
      "eval_exit_code": null,
      "eval_timed_out": null
    },
    {
      "instance_id": "rocprim_rocprim_include_rocprim_device_device_merge_sort_hpp",
      "success": true,
      "reward": 0.0,
      "speedup": -1.0,
      "exit_status": "Submitted",
      "error": null,
      "git_diff": "diff --git a/projects/rocprim/rocprim/include/rocprim/device/device_merge_sort.hpp b/projects/rocprim/rocprim/include/rocprim/device/device_merge_sort.hpp\nindex 97a83fee0b..0371c6d167 100644\n--- a/projects/rocprim/rocprim/include/rocprim/device/device_merge_sort.hpp\n+++ b/projects/rocprim/rocprim/include/rocprim/device/device_merge_sort.hpp\n@@ -325,7 +325,7 @@ inline hipError_t merge_sort_block_merge_impl(\n     const merge_sort_block_merge_config_params params\n         = dispatch_target_arch<config, false>(target_arch);\n \n-    const unsigned int merge_oddeven_block_size = params.merge_oddeven_config.block_size;\n+    const unsigned int merge_oddeven_block_size = std::max(256, std::min(512, size));\n     const unsigned int merge_oddeven_items_per_thread\n         = params.merge_oddeven_config.items_per_thread;\n     const unsigned int merge_oddeven_items_per_block\n@@ -333,7 +333,7 @@ inline hipError_t merge_sort_block_merge_impl(\n \n     const unsigned int merge_partition_block_size\n         = params.merge_mergepath_partition_config.block_size;\n-    const unsigned int merge_mergepath_block_size = params.merge_mergepath_config.block_size;\n+    const unsigned int merge_mergepath_block_size = std::max(256, std::min(512, size));\n     const unsigned int merge_mergepath_items_per_thread\n         = params.merge_mergepath_config.items_per_thread;\n     const unsigned int merge_mergepath_items_per_block\n@@ -544,7 +544,7 @@ inline hipError_t merge_sort_block_merge(\n     const merge_sort_block_merge_config_params params\n         = dispatch_target_arch<config, false>(target_arch);\n \n-    const unsigned int merge_mergepath_block_size = params.merge_mergepath_config.block_size;\n+    const unsigned int merge_mergepath_block_size = std::max(256, std::min(512, size));\n     const unsigned int merge_mergepath_items_per_thread\n         = params.merge_mergepath_config.items_per_thread;\n     const unsigned int merge_mergepath_items_per_block\n",
      "model_calls": 8,
      "eval_success": false,
      "eval_reason": null,
      "eval_error": "Test build failed",
      "eval_exit_code": null,
      "eval_timed_out": null
    },
    {
      "instance_id": "rocprim_rocprim_include_rocprim_block_block_adjacent_difference_hpp",
      "success": false,
      "reward": 0.0,
      "speedup": null,
      "exit_status": "error",
      "error": "RetryError[<Future at 0x7f3efeb022d0 state=finished raised BadRequestError>]",
      "git_diff": null,
      "model_calls": 0,
      "eval_success": false,
      "eval_reason": null,
      "eval_error": "RetryError[<Future at 0x7f3efeb022d0 state=finished raised BadRequestError>]"
    },
    {
      "instance_id": "rocprim_rocprim_include_rocprim_device_device_merge_inplace_hpp",
      "success": true,
      "reward": 0.0,
      "speedup": -1.0,
      "exit_status": "Submitted",
      "error": null,
      "git_diff": null,
      "model_calls": 38,
      "eval_success": false,
      "eval_reason": null,
      "eval_error": "No changes detected relative to HEAD",
      "eval_exit_code": null,
      "eval_timed_out": null
    },
    {
      "instance_id": "rocprim_rocprim_include_rocprim_device_device_partial_sort_hpp",
      "success": true,
      "reward": 0.0,
      "speedup": -1.0,
      "exit_status": "Submitted",
      "error": null,
      "git_diff": "diff --git a/projects/rocprim/rocprim/include/rocprim/device/device_partial_sort.hpp b/projects/rocprim/rocprim/include/rocprim/device/device_partial_sort.hpp\nindex 1653e0c060..89f33f9333 100644\n--- a/projects/rocprim/rocprim/include/rocprim/device/device_partial_sort.hpp\n+++ b/projects/rocprim/rocprim/include/rocprim/device/device_partial_sort.hpp\n@@ -61,7 +61,7 @@ struct radix_sort_condition_checker\n     static constexpr bool ascending = std::is_same<BinaryFunction, rocprim::less<key_type>>::value;\n     static constexpr bool is_radix_key_fundamental\n         = rocprim::traits::radix_key_codec::radix_key_fundamental<key_type>::value;\n-    static constexpr bool use_radix_sort\n+    static constexpr bool use_radix_sort = (is_radix_key_fundamental || is_custom_decomposer) static constexpr bool use_radix_sortstatic constexpr bool use_radix_sort (descending || ascending);\n         = (is_radix_key_fundamental || is_custom_decomposer) && (descending || ascending);\n };\n \n@@ -89,7 +89,7 @@ struct SortImpl\n                          Decomposer /*decomposer*/)\n     {\n         // Merge sort implementation\n-        return detail::merge_sort_impl<typename config::merge_sort>(\n+        return detail::merge_sort_impl<typename config::merge_sort>(keys_input, keys_output, size, compare_function, static_cast<empty_type*>(nullptr), static_cast<empty_type*>(nullptr), \n             temporary_storage,\n             storage_size,\n             keys_input,\n",
      "model_calls": 24,
      "eval_success": false,
      "eval_reason": null,
      "eval_error": "Test build failed",
      "eval_exit_code": null,
      "eval_timed_out": null
    },
    {
      "instance_id": "rocprim_rocprim_include_rocprim_device_device_partial_sort_copy_hpp",
      "success": true,
      "reward": 0.0,
      "speedup": -1.0,
      "exit_status": "Submitted",
      "error": null,
      "git_diff": null,
      "model_calls": 20,
      "eval_success": false,
      "eval_reason": null,
      "eval_error": "No changes detected relative to HEAD",
      "eval_exit_code": null,
      "eval_timed_out": null
    },
    {
      "instance_id": "rocprim_rocprim_include_rocprim_device_device_nth_element_hpp",
      "success": true,
      "reward": 0.0,
      "speedup": -1.0,
      "exit_status": "Submitted",
      "error": null,
      "git_diff": "diff --git a/projects/rocprim/rocprim/include/rocprim/device/detail/device_nth_element.hpp b/projects/rocprim/rocprim/include/rocprim/device/detail/device_nth_element.hpp\nindex 7a460cafd1..d6a5966326 100644\n--- a/projects/rocprim/rocprim/include/rocprim/device/detail/device_nth_element.hpp\n+++ b/projects/rocprim/rocprim/include/rocprim/device/detail/device_nth_element.hpp\n@@ -179,7 +179,7 @@ ROCPRIM_DEVICE ROCPRIM_FORCE_INLINE void find_splitters_kernel_impl(\n                                BinaryFunction compare_function)\n {\n     constexpr nth_element_config_params params        = ArchConfig::params;\n-    constexpr unsigned int              num_splitters = params.number_of_buckets - 1;\n+    constexpr unsigned int              num_splitters = std::min(params.number_of_buckets - 1, static_cast<unsigned int>(std::sqrt(size)));\n \n     using key_type = typename std::iterator_traits<KeysIterator>::value_type;\n \n",
      "model_calls": 36,
      "eval_success": false,
      "eval_reason": null,
      "eval_error": "Test build failed",
      "eval_exit_code": null,
      "eval_timed_out": null
    },
    {
      "instance_id": "rocprim_rocprim_include_rocprim_device_device_reduce_hpp",
      "success": true,
      "reward": 0.0,
      "speedup": -1.0,
      "exit_status": "Submitted",
      "error": null,
      "git_diff": null,
      "model_calls": 2,
      "eval_success": false,
      "eval_reason": null,
      "eval_error": "No changes detected relative to HEAD",
      "eval_exit_code": null,
      "eval_timed_out": null
    }
  ],
  "summary": {
    "successful": 23,
    "failed": 1,
    "average_reward": 0.004166666666666666,
    "total_reward": 0.09999999999999998
  }
}